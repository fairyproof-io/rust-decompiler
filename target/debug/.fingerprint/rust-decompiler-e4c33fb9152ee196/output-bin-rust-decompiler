{"message":"type `Option<&&str>` cannot be dereferenced","code":{"code":"E0614","explanation":"Attempted to dereference a variable which cannot be dereferenced.\n\nErroneous code example:\n\n```compile_fail,E0614\nlet y = 0u32;\n*y; // error: type `u32` cannot be dereferenced\n```\n\nOnly types implementing `std::ops::Deref` can be dereferenced (such as `&T`).\nExample:\n\n```\nlet y = 0u32;\nlet x = &y;\n// So here, `x` is a `&u32`, so we can dereference it:\n*x; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/opcodes.rs","byte_start":8959,"byte_end":8980,"line_start":370,"line_end":370,"column_start":25,"column_end":46,"is_primary":true,"text":[{"text":"        write!(f, \"{}\", *OPCODE_MAP.get(self))","highlight_start":25,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0614]\u001b[0m\u001b[0m\u001b[1m: type `Option<&&str>` cannot be dereferenced\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/opcodes.rs:370:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m370\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        write!(f, \"{}\", *OPCODE_MAP.get(self))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"cannot subtract `OpCode` from `&OpCode`","code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","spans":[{"file_name":"src/asm.rs","byte_start":2164,"byte_end":2172,"line_start":84,"line_end":84,"column_start":20,"column_end":28,"is_primary":false,"text":[{"text":"            let a= &self.op - OpCode::PUSH1 + 1;","highlight_start":20,"highlight_end":28}],"label":"&OpCode","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/asm.rs","byte_start":2175,"byte_end":2188,"line_start":84,"line_end":84,"column_start":31,"column_end":44,"is_primary":false,"text":[{"text":"            let a= &self.op - OpCode::PUSH1 + 1;","highlight_start":31,"highlight_end":44}],"label":"OpCode","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/asm.rs","byte_start":2173,"byte_end":2174,"line_start":84,"line_end":84,"column_start":29,"column_end":30,"is_primary":true,"text":[{"text":"            let a= &self.op - OpCode::PUSH1 + 1;","highlight_start":29,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0369]\u001b[0m\u001b[0m\u001b[1m: cannot subtract `OpCode` from `&OpCode`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/asm.rs:84:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let a= &self.op - OpCode::PUSH1 + 1;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mOpCode\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m&OpCode\u001b[0m\n\n"}
{"message":"non-primitive cast: `u8` as `OpCode`","code":{"code":"E0605","explanation":"An invalid cast was attempted.\n\nErroneous code examples:\n\n```compile_fail,E0605\nlet x = 0u8;\nx as Vec<u8>; // error: non-primitive cast: `u8` as `std::vec::Vec<u8>`\n\n// Another example\n\nlet v = core::ptr::null::<u8>(); // So here, `v` is a `*const u8`.\nv as &u8; // error: non-primitive cast: `*const u8` as `&u8`\n```\n\nOnly primitive types can be cast into each other. Examples:\n\n```\nlet x = 0u8;\nx as u32; // ok!\n\nlet v = core::ptr::null::<u8>();\nv as *const i8; // ok!\n```\n\nFor more information about casts, take a look at the Type cast section in\n[The Reference Book][1].\n\n[1]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\n"},"level":"error","spans":[{"file_name":"src/asm.rs","byte_start":2075,"byte_end":2112,"line_start":82,"line_end":82,"column_start":19,"column_end":56,"is_primary":true,"text":[{"text":"        self.op = self.code[self.pc as usize] as OpCode;","highlight_start":19,"highlight_end":56}],"label":"an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0605]\u001b[0m\u001b[0m\u001b[1m: non-primitive cast: `u8` as `OpCode`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/asm.rs:82:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        self.op = self.code[self.pc as usize] as OpCode;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9man `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0369, E0605, E0614.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0369, E0605, E0614.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0369`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0369`.\u001b[0m\n"}
